<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ns="http://www.w3.org/1999/xhtml">
  <head>
    <link href="./webrtc.css" rel="stylesheet" type="text/css" />

    <title>JSEP1 BRANCH - WebRTC 1.0: Real-time Communication Between
    Browsers</title>

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

    <!--
     === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline.

      To tag a new releas in git hub

          Once the version is checked in and ready to go, you tag it with (need
          to chance the 20110823 to correct date )

               git tag -a v20120323 -m "This is release 20120323"

         Tags are not transferred by default with the push so you have to
         add a - -tags parameter to the push so it looks like. Note you need to
         remoce the space between the - and -tag to make a double dash. 

              git push - -tags 

         or alternatively you can push just the new tag with 

              git push origin v20120323


      To generate the dated version of the specification:

           Open this doc in Mozilla. 

           Do a CTRL-ALT-SHIFT-S

           Select "XHMTL( source)" from dialog box. This will pop a new tab with
           genreated version of the document.

           This will open a new tab with generated html. Copy and paste this to
           a new file. Note if you use Chrome or Safari, this step will not
           work. What will happen is the paste will have the original document,
           not what was displayed in the window that you did the copy on.

           Rename the new file to the correct day such as
           webrtc-broken-20111003.html then search for and edit the links for
           "This version" and "Previos version". Add the new file into CVS and
           check in. 

           Once everyone is happy, the webrtc-broken.html and
           webrtc-broken-20111003.html files can be coppied to
           webrtc.html and webrtc-20111003.html
           respectively in the ../editor/. directory. 
    -->

    <script class="remove" src="ReSpec.js/js/respec.js" type="text/javascript">
      <!-- keep this comment -->
    </script>

    <script class="remove" src="webrtc.js" type="text/javascript">
      <!-- keep
    this comment -->
    </script>
  </head>

  <body>
    <section id="abstract">
      <p> This is not a product of the WebRTC WG - it is merely a document
      being used to discuss possible changes to the documents that WG is
      developing. Much of the text here is from the WG document.</p>

      <p>This document defines a set of APIs to represent streaming media,
      including audio and video, in JavaScript, to allow media to be sent over
      the network to another browser or device implementing the appropriate
      set of real-time protocols, and media received from another browser or
      device to be processed and displayed locally. This specification is
      being developed in conjunction with a protocol specification developed
      by the IETF RTCWEB group and an API specification to get access to local
      media devices developed by the Media Capture Task Force.</p>
    </section>

    <section id="conformance">
      <p> Implementations that use ECMAScript to implement the APIs defined in
      this specification must implement them in a manner consistent with the
      ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
      this specification uses that specification and terminology. </p>
    </section>

    <section id="sotd">
      <p>This document is not complete. It is subject to major changes and,
      while early experimentations are encouraged, it is therefore not
      intended for implementation. The API is based on preliminary work done
      in the WHATWG. The Web Real-Time Communications Working Group expects
      this specification to evolve significantly based on:</p>

      <ul>
        <li>The outcomes of ongoing exchanges in the companion RTCWEB group at
        IETF to define the set of protocols that, together with this document,
        will enable real-time communications in Web browsers.</li>

        <li>Privacy issues that arise when exposing local capabilities and
        local streams.</li>

        <li>Technical discussions within the group, on the data channel in
        particular.</li>

        <li>Experience gained through early experimentations.</li>

        <li>Feedback received from other groups and individuals.</li>
      </ul>
    </section>

    <section class="informative" id="intro">
      <h2>Introduction</h2>

      <p>There are a number of facets to video-conferencing in HTML covered by
      this specification:</p>

      <ul>
        <li>Representing a multimedia stream (video, audio, or both) from
        local devices (video cameras, microphones, Web cams) or from
        prerecorded files provided by the user.</li>

        <li>Recording such streams locally.</li>

        <li>Connecting to remote peers using NAT-traversal technologies such
        as ICE, STUN, and TURN.</li>

        <li>Sending the locally-produced streams to remote peers and receiving
        streams from remote peers.</li>

        <li>Displaying such streams (both the locally-produced ones and the
        remotely-obtained ones) locally using the <code>video</code> or
        <code>audio</code> elements.</li>

        <li>Sending arbitrary data to remote peers.</li>
      </ul>

      <p>This document defines the APIs used for these features. This
      specification is being developed in conjunction with a protocol
      specification developed by the <a
      href="http://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and
      an API specification to get access to local media devices developed by
      the <a href="http://www.w3.org/2011/04/webrtc/">Media Capture Task
      Force</a>.</p>
    </section>

    <section>
      <h2>Stream API</h2>

      <section>
        <h3>Introduction</h3>

        <p>The <code>
            <a>MediaStream</a>
          </code> interface is used to represent streams of media data,
        typically (but not necessarily) of audio and/or video content, e.g.
        from a local camera or a remote site. The data from a <code>
            <a>MediaStream</a>
          </code> object does not necessarily have a canonical binary form;
        for example, it could just be "the video currently coming from the
        user's video camera". This allows user agents to manipulate media
        streams in whatever fashion is most suitable on the user's
        platform.</p>

        <p>Each <code>
            <a>MediaStream</a>
          </code> object can contain zero or more tracks, in particular audio
        and video tracks. All tracks in a MediaStream are intended to be
        synchronized when rendered. Different MediaStreams do not need to be
        synchronized.</p>

        <p>Each track in a MediaStream object has a corresponding <code>
            <a>MediaStreamTrack</a>
          </code> object.</p>

        <p>A <code>
            <a>MediaStreamTrack</a>
          </code> represents content comprising one or more channels, where
        the channels have a defined well known relationship to each other
        (such as a stereo or 5.1 audio signal), and are intended to be encoded
        together for transmission as, for instance, an RTP payload type. One
        <code>
            <a>MediaStreamTrack</a>
          </code> sent to another peer MUST appear as one and only one <code>
            <a>MediaStreamTrack</a>
          </code> to the recipient. All of the channels that a codec needs to
        encode the media MUST be in the same <code>
            <a>MediaStreamTrack</a>
          </code> and the codecs SHOULD be able to encode, or discard, all the
        channels in the track. </p>

        <p>A channel is the smallest atomic unit of media considered in this
        API specification.</p>

        <p>A <code>
            <a>MediaStream</a>
          </code> object has an input and an output. The input depends on how
        the object was created: a <code>
            <a>LocalMediaStream</a>
          </code> object generated by a <code>getUserMedia()</code>
        [[!GETUSERMEDIA]] call, for instance, might take its input from the
        user's local camera, while a <code>
            <a>MediaStream</a>
          </code> created by a <code>
            <a>PeerConnection</a>
          </code> object will take as input the data received from a remote
        peer. The output of the object controls how the object is used, e.g.
        what is saved if the object is written to a file, what is displayed if
        the object is used in a <code>video</code> element, or indeed what is
        transmitted to a remote peer if the object is used with a <code>
            <a>PeerConnection</a>
          </code> object.</p>

        <p>Each track in a <code>
            <a>MediaStream</a>
          </code> object can be disabled, meaning that it is muted in the
        object's output. All tracks are initially enabled.</p>

        <p>A <code>
            <a>MediaStream</a>
          </code> can be <a>finished</a>, indicating that its inputs have
        forever stopped providing data.</p>

        <p>The output of a <code>
            <a>MediaStream</a>
          </code> object MUST correspond to the tracks in its input. Muted
        audio tracks MUST be replaced with silence. Muted video tracks MUST be
        replaced with blackness.</p>

        <p>A new <code>
            <a>MediaStream</a>
          </code> object can be created from existing <code>
            <a>MediaStreamTrack</a>
          </code> objects using the <code>
            <a href="#dom-mediastream">MediaStream()</a>
          </code> constructor. The constructor takes two lists of <code>
            <a>MediaStreamTrack</a>
          </code> objects as arguments; one for audio tracks and one for video
        tracks. The lists can either be the track lists of another stream,
        subsets of such lists, or compositions of <code>
            <a>MediaStreamTrack</a>
          </code> objects from different <code>
            <a>MediaStream</a>
          </code> objects. </p>

        <p>
          <img alt="" src="images/media-stream-1.png" />
        </p>

        <!-- no alt since
  it's all described in the previous paragraphs: this is just a
  summary -->

        <!--
c.clearRect(0, 0, 640, 480);
c.save();
try {
  with (c) {
    save();
    strokeStyle = '#AA0000';
    lineWidth = 20;
    beginPath();
    moveTo(50,98);
    lineTo(550, 98);
    stroke();
  }
  mediaStream(c,50,10, true);

} finally {
  c.restore();
}

function cameraIcon(c,x,y) {
  with (c) { save(); try {
    translate(x,y);
    fillRect(-10,-10,20,20);
    beginPath();
    moveTo(7,0);
    lineTo(20,-10);
    lineTo(20,10);
    fill();
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'center';
    textBaseline = 'top';
    fillText('Camera', 4, 15);
  } finally { restore(); } }
}

function mediaStream(c,x,y,vid) {
  with (c) {
    save();
    translate(x-10,y-97);

    // cable
    fillStyle = 'black';
    font = '100 10px "Press Start 2P", sans-serif';
    textAlign = 'right';
    fillText('Input', 95, 170);
    textAlign = 'left';
    fillText('Output', 407, 170);

    // media stream
    fillStyle = '#EE8800';
    strokeStyle = '#FFCC00';
    lineWidth = 6;
    fillRect(100,100,300,170);
    strokeRect(100,100,300,170);
    fillStyle = 'black';
    font = '900 12px "Press Start 2P", sans-serif';
    textAlign = 'left';
    fillText('MediaStream', 110, 123);

    // tracks
    textAlign = 'left';
    strokeStyle = '#CC3300';
    fillStyle = '#FFFF00';
    lineWidth = 4;
    globalAlpha = vid ? 1 : 0.4;
    fillRect(120,140,100,110);
    strokeRect(120,140,100,110);
    globalAlpha = 1;
    fillRect(238,140,100,110);
    strokeRect(238,140,100,110);
    fillStyle = 'black';
    font = '900 10px "Press Start 2P", sans-serif';
    globalAlpha = vid ? 1 : 0.4;
    fillText('Track', 123, 155);
    fillText('(video)', 123, 170);
    globalAlpha = 1;
    fillText('Track', 241, 155);
    fillText('(stereo', 241, 170);
    fillText(' audio)', 241, 185);

    // channels
    strokeStyle = '#999999';
    fillStyle = '#FFFFFF';
    lineWidth = 2;
    fillRect(245,191,86,23);
    strokeRect(245,191,86,23);
    fillRect(245,220,86,23);
    strokeRect(245,220,86,23);
    fillStyle = 'black';
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'left';
    textBaseline = 'alphabetic';
    fillText('left', 249, 202);
    fillText('channel', 249, 211);
    fillText('right', 249, 231);
    fillText('channel', 249, 240);

    // track check marks
    fillStyle = 'black';
    font = '900 35px "Lucida Grande", sans-serif';
    textAlign = 'center';
    textBaseline = 'middle';
    fillText(vid ? '\u2713' : '\u2716', 220, 245);
    fillText('\u2713', 338, 245);

    restore();
  }
}
-->

        <p>The ability to duplicate a <code>
            <a>MediaStream</a>
          </code>, i.e. create a new <code>
            <a>MediaStream</a>
          </code> object from the track lists of an existing stream, allows
        for greater control since separate <code>
            <a>MediaStream</a>
          </code> instances can be manipulated and <a
        title="consumer">consumed</a> individually. This can be used, for
        instance, in a video-conferencing scenario to display the local video
        from the user's camera and microphone in a local monitor, while only
        transmitting the audio to the remote peer (e.g. in response to the
        user using a "video mute" feature). Combining tracks from different
        <code>
            <a>MediaStream</a>
          </code> objects into a new <code>
            <a>MediaStream</a>
          </code> makes it possible to, e.g., record selected tracks from a
        conversation involving several <code>
            <a href="#mediastream">MediaStream</a>
          </code> objects with a single <code>
            <a href="#mediastreamrecorder">MediaStreamRecorder</a>
          </code>.</p>

        <!--
c.clearRect(0, 0, 640, 480);
c.save();
try {
  with (c) {
    save();
    strokeStyle = '#AA0000';
    lineWidth = 20;
    beginPath();
    moveTo(50,98);
    lineTo(550, 98);
    lineTo(550, 210);
    lineTo(50, 210);
    lineTo(50, 320);
    lineTo(550, 320);
    lineTo(550,420);
    stroke();
    beginPath();
    moveTo(50,320);
    lineTo(50,420);
    stroke();
    restore();
    fillStyle = 'black';
    font = '100 10px "Press Start 2P", sans-serif';
    textAlign = 'center';
    fillText('<video>', 50, 440);
    fillText('PeerConnection', 550, 440);
    font = '100 8px "Press Start 2P", sans-serif';
  }
  cameraIcon(c,25,98)
  mediaStream(c,50,10, true);
  mediaStream(c,50,233, false);

  with (c) {
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'left';
    textBaseline = 'middle';
    fillStyle = 'gray';

    fillText('from', 4, 130);
    fillText('getUserMedia()', 4, 140);

    fillText('via URL.createObjectURL()', 4, 450);

    textAlign = 'center';
    fillText('via addStream()', 550, 450);
  }
} finally {
  c.restore();
}

function cameraIcon(c,x,y) {
  with (c) { save(); try {
    translate(x,y);
    fillRect(-10,-10,20,20);
    beginPath();
    moveTo(7,0);
    lineTo(20,-10);
    lineTo(20,10);
    fill();
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'center';
    textBaseline = 'top';
    fillText('Camera', 4, 15);
  } finally { restore(); } }
}

function mediaStream(c,x,y,vid) {
  with (c) {
    save();
    translate(x-10,y-97);

    // cable
    fillStyle = 'black';
    font = '100 10px "Press Start 2P", sans-serif';
    textAlign = 'right';
    fillText('Input', 95, 170);
    textAlign = 'left';
    fillText('Output', 407, 170);

    // media stream
    fillStyle = '#EE8800';
    strokeStyle = '#FFCC00';
    lineWidth = 6;
    fillRect(100,100,300,170);
    strokeRect(100,100,300,170);
    fillStyle = 'black';
    font = '900 12px "Press Start 2P", sans-serif';
    textAlign = 'left';
    fillText(!vid ? 'MediaStream' : 'LocalMediaStream', 110, 123);

    // tracks
    textAlign = 'left';
    strokeStyle = '#CC3300';
    fillStyle = '#FFFF00';
    lineWidth = 4;
    globalAlpha = vid ? 1 : 0.4;
    fillRect(120,140,100,110);
    strokeRect(120,140,100,110);
    globalAlpha = 1;
    fillRect(238,140,100,110);
    strokeRect(238,140,100,110);
    fillStyle = 'black';
    font = '900 10px "Press Start 2P", sans-serif';
    globalAlpha = vid ? 1 : 0.4;
    fillText('Track', 123, 155);
    fillText('(video)', 123, 170);
    globalAlpha = 1;
    fillText('Track', 241, 155);
    fillText('(stereo', 241, 170);
    fillText(' audio)', 241, 185);

    // channels
    strokeStyle = '#999999';
    fillStyle = '#FFFFFF';
    lineWidth = 2;
    fillRect(245,191,86,23);
    strokeRect(245,191,86,23);
    fillRect(245,220,86,23);
    strokeRect(245,220,86,23);
    fillStyle = 'black';
    font = '100 8px "Press Start 2P", sans-serif';
    textAlign = 'left';
    textBaseline = 'alphabetic';
    fillText('left', 249, 202);
    fillText('channel', 249, 211);
    fillText('right', 249, 231);
    fillText('channel', 249, 240);

    // track check marks
    fillStyle = 'black';
    font = '900 35px "Lucida Grande", sans-serif';
    textAlign = 'center';
    textBaseline = 'middle';
    fillText(vid ? '\u2713' : '\u2716', 220, 245);
    fillText('\u2713', 338, 245);

    restore();
  }
}
-->

        <p>The <code>
            <a>LocalMediaStream</a>
          </code> interface is used when the user agent is generating the
        stream's data (e.g. from a camera or streaming it from a local video
        file).</p>

        <p>When a <code>
            <a>LocalMediaStream</a>
          </code> object is being generated from a local file (as opposed to a
        live audio/video source), the user agent SHOULD stream the data from
        the file in real time, not all at once. This reduces the ease with
        which pages can distinguish live video from pre-recorded video, which
        can help protect the user's privacy.</p>
      </section>

      <section>
        <h3>Interface definitions</h3>

        <section>
          <h4>MediaStream</h4>

          <p>The <dfn id="dom-mediastream">
              <code>MediaStream()</code>
            </dfn> constructor takes two arguments. The arguments are two
          lists with <code>
              <a>MediaStreamTrack</a>
            </code> objects which will be used to construct the audio and
          video track lists of the new <code>
              <a>MediaStream</a>
            </code> object. When the constructor is invoked, the UA must run
          the following steps:</p>

          <ol>
            <li>
              <p>Let <var>audioTracks</var> be the constructor's first
              argument.</p>
            </li>

            <li>
              <p>Let <var>videoTracks</var> be the constructor's second
              argument.</p>
            </li>

            <li>
              <p>Let <var>stream</var> be a newly constructed <code>
                  <a>MediaStream</a>
                </code> object.</p>
            </li>

            <li>
              <p>Set <var>stream's</var> label attribute to a newly generated
              value.</p>
            </li>

            <li>
              <p>If <var>audioTracks</var> is not null, then run the following
              sub steps for each element <var>track</var> in
              <var>audioTracks</var>:</p>

              <ol>
                <li>
                  <p>If <var>track</var> is of any other kind than
                  "<code>audio</code>", then throw a <code>SyntaxError</code>
                  exception.</p>
                </li>

                <li>
                  <p>If <var>track</var> has the same underlying source as
                  another element in <var>stream's</var> audio track list,
                  then abort these steps.</p>
                </li>

                <li>
                  <p>Add <var>track</var> to <var>stream's</var> audio track
                  list.</p>
                </li>
              </ol>
            </li>

            <li>
              <p>If <var>videoTracks</var> is not null, then run the following
              sub steps for each element <var>track</var> in
              <var>videoTracks</var>:</p>

              <ol>
                <li>
                  <p>If <var>track</var> is of any other kind than
                  "<code>video</code>", then throw a <code>SyntaxError</code>
                  exception.</p>
                </li>

                <li>
                  <p>If <var>track</var> has the same underlying source as
                  another element in <var>stream's</var> video track list,
                  then abort these steps.</p>
                </li>

                <li>
                  <p>Add <var>track</var> to <var>stream's</var> video track
                  list.</p>
                </li>
              </ol>
            </li>
          </ol>

          <p>A <code>
              <a>MediaStream</a>
            </code> can have multiple audio and video sources (e.g. because
          the user has multiple microphones, or because the real source of the
          stream is a media resource with many media tracks). The stream
          represented by a <code>
              <a>MediaStream</a>
            </code> thus has zero or more tracks.</p>

          <p>The tracks of a <code>
              <a>MediaStream</a>
            </code> are stored in two track lists represented by <code>
              <a>MediaStreamTrackList</a>
            </code> objects; one for audio tracks and one for video tracks.
          The two track lists MUST contain the <code>
              <a>MediaStreamTrack</a>
            </code> objects that correspond to the tracks of the stream. The
          relative order of all tracks in a user agent MUST be stable. Tracks
          that come from a media resource whose format defines an order MUST
          be in the order defined by the format; tracks that come from a media
          resource whose format does not define an order MUST be in the
          relative order in which the tracks are declared in that media
          resource. Within these constraints, the order is user-agent
          defined.</p>

          <p>An object that reads data from the output of a <code>
              <a>MediaStream</a>
            </code> is referred to as a <code>
              <a>MediaStream</a>
            </code> <dfn>consumer</dfn>. The list of <code>
              <a>MediaStream</a>
            </code> consumers currently include the media elements, <code>
              <a>PeerConnection</a>
            </code> and <code>
              <a>MediaStreamRecorder</a>
            </code>.</p>

          <p class="note"><code>
              <a>MediaStream</a>
            </code> consumers be able to handle tracks being added and
          removed. This behavior is specifier per consumer.</p>

          <p>A new media component may be associated with an existing <code>
              <a>MediaStream</a>
            </code>. This happens, e.g., on the A-side when the B-side adds a
          new <code>
              <a>MediaStreamTrack</a>
            </code> object to one of the track lists of a <code>
              <a>MediaStream</a>
            </code> that is being sent over a <code>
              <a>PeerConnection</a>
            </code>. If this happens for the reason exemplified, or for any
          other reason than the <code>
              <a href="#dom-mediastreamtracklist-add">add()</a>
            </code> method being invoked locally on a <code>
              <a>MediaStreamTrackList</a>
            </code> or tracks are being added as the stream is created (i.e.
          the stream is initialized with tracks), the user agent MUST run the
          following steps:</p>

          <ol>
            <li>
              <p>Create a <code>
                  <a>MediaStreamTrack</a>
                </code> object <var>track</var> to represent the new media
              component.</p>
            </li>

            <li>
              <p>If <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> attribute equals "<code>audio</code>", add it to the
              <code>
                  <a>MediaStream</a>
                </code> object's <code>
                  <a href="#dom-mediastream-audiotracks">audioTracks</a>
                </code> <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>

            <li>
              <p>If <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> attribute equals "<code>video</code>", add it to the
              <code>
                  <a>MediaStream</a>
                </code> object's <code>
                  <a href="#dom-mediastream-videotracks">videoTracks</a>
                </code> <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>

            <li>
              <p><a>Fire a track event</a> named <code>
                  <a href="#event-mediastreamtracklist-addtrack">addtrack</a>
                </code> with the newly created <var>track</var> at the <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>
          </ol>

          <p>An existing media component may also be disassociated from a
          <code>
              <a>MediaStream</a>
            </code>. If this happens for any other reason than the <code>
              <a href="#dom-mediastreamtracklist-remove">remove()</a>
            </code> method being invoked locally on a <code>
              <a>MediaStreamTrackList</a>
            </code> or the stream is being destroyed, the user agent MUST run
          the following steps:</p>

          <ol>
            <li>
              <p>Let <var>track</var> be the <code>
                  <a>MediaStreamTrack</a>
                </code> object representing the media component about to be
              removed.</p>
            </li>

            <li>
              <p>Remove <var>track</var> from the <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>

            <li>
              <p><a>Fire a track event</a> named <code>
                  <a
                  href="#event-mediastreamtracklist-removetrack">removetrack</a>
                </code> with <var>track</var> at the <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>
          </ol>

          <p>A <code>
              <a>MediaStream</a>
            </code> object is said to be <dfn>finished</dfn> when all tracks
          belonging to the stream have <a>ended</a>. When this happens for any
          reason other than the <code>
              <a href="#dom-mediastream-stop">stop()</a>
            </code> method being invoked, the user agent MUST queue a task
          that runs the following steps:</p>

          <ol>
            <li>
              <p>If the object's <code>
                  <a href="#dom-mediastream-ended">ended</a>
                </code> attribute has the value true already, then abort these
              steps. (The <code>
                  <a href="#dom-mediastream-stop">stop()</a>
                </code> method was probably called just before the stream
              stopped for other reasons, e.g. the user clicked an in-page stop
              button and then the user agent provided stop button.)</p>
            </li>

            <li>
              <p>Set the object's <code>
                  <a href="#dom-mediastream-ended">ended</a>
                </code> attribute to true.</p>
            </li>

            <li>
              <p>Fire a simple event named <code
                  title="event-MediaStream-ended">
                  <a href="#event-mediastream-ended">ended</a>
                </code> at the object.</p>
            </li>
          </ol>

          <p>If the end of the stream was reached due to a user request, the
          task source for this <span title="concept-task">task</span> is the
          user interaction task source. Otherwise the task source for this
          <span title="concept-task">task</span> is the networking task
          source.</p>

          <dl class="idl"
              title="[Constructor (MediaStreamTrackList? audioTracks, MediaStreamTrackList? videoTracks)]     interface MediaStream">
            <dt>readonly attribute DOMString label</dt>

            <dd>
              <p>Returns a label that is unique to this stream, so that
              streams can be recognized after they are sent through the <code>
                  <a href="#peerconnection">PeerConnection</a>
                </code> API.</p>

              <p>When a <code>
                  <a href="#localmediastream">LocalMediaStream</a>
                </code> object is created, the user agent MUST generate a
              globally unique identifier string, and MUST initialize the
              object's <code>
                  <a href="#dom-mediastream-label">label</a>
                </code> attribute to that string. Such strings MUST only use
              characters in the ranges U+0021, U+0023 to U+0027, U+002A to
              U+002B, U+002D to U+002E, U+0030 to U+0039, U+0041 to U+005A,
              U+005E to U+007E, and MUST be 36 characters long.</p>

              <!-- UUIDs have 36
      characters including hyphens; the ranges above comes from RFC4574 (the
      a=label: thing in SDP) -->

              <p class="note"> TODO NOTE - I think we have this slightly
              wrong. It is the Track on the Stream that needs the label. Also,
              how do you set the label on a Track. </p>

              <p>When a <code>
                  <a href="#mediastream">MediaStream</a>
                </code> is created to represent a stream obtained from a
              remote peer, the <code title="dom-MediaStream-label">
                  <a href="#dom-mediastream-label">label</a>
                </code> attribute is initialized from information provided by
              the remote source.</p>

              <!-- described below -->

              <p>When a <code>
                  <a>MediaStream</a>
                </code> is created from another using the <code>
                  <a href="#dom-mediastream">MediaStream()</a>
                </code> constructor, the <code title="dom-MediaStream-label">
                  <a href="#dom-mediastream-label">label</a>
                </code> attribute is initialized to a newly generated
              value.</p>

              <!-- described above -->

              <p>The <dfn id="dom-mediastream-label">
                  <code>label</code>
                </dfn> attribute MUST return the value to which it was
              initialized when the object was created.</p>

              <p class="note">The label of a <code>
                  <a>MediaStream</a>
                </code> object is unique to the source of the stream, but that
              does not mean it is not possible to end up with duplicates. For
              example, a locally generated stream could be sent from one user
              to a remote peer using <code>
                  <a>PeerConnection</a>
                </code>, and then sent back to the original user in the same
              manner, in which case the original user will have multiple
              streams with the same label (the locally-generated one and the
              one received from the remote peer).</p>
            </dd>

            <dt>readonly attribute MediaStreamTrackList audioTracks</dt>

            <dd>
              <p>Returns a <code>
                  <a>MediaStreamTrackList</a>
                </code> object representing the audio tracks that can be
              enabled and disabled.</p>

              <p>The <dfn id="dom-mediastream-audiotracks">
                  <code>audioTracks</code>
                </dfn> attribute MUST return an <span
              title="array host objects">array host object</span> for objects
              of type <code>
                  <a>MediaStreamTrack</a>
                </code> that is <em>fixed length</em> and <em>read only</em>.
              The same object MUST be returned each time the attribute is
              accessed.</p>
            </dd>

            <dt>readonly attribute MediaStreamTrackList videoTracks</dt>

            <dd>
              <p>Returns a <code>
                  <a>MediaStreamTrackList</a>
                </code> object representing the video tracks that can be
              enabled and disabled.</p>

              <p>The <dfn id="dom-mediastream-videotracks">
                  <code>videoTracks</code>
                </dfn> attribute MUST return an <span
              title="array host objects">array host object</span> for objects
              of type <code>
                  <a>MediaStreamTrack</a>
                </code> that is <em>fixed length</em> and <em>read only</em>.
              The same object MUST be returned each time the attribute is
              accessed. </p>
            </dd>

            <dt>MediaStreamRecorder record()</dt>

            <dd>
              <p>Begins recording the stream. The returned <code>
                  <a>MediaStreamRecorder</a>
                </code> object provides access to the recorded data.</p>

              <p>When the <dfn id="dom-mediastream-record">
                  <code>record()</code>
                </dfn> method is invoked, the user agent MUST return a new
              <code>
                  <a>MediaStreamRecorder</a>
                </code> object associated with the stream.</p>
            </dd>

            <dt>attribute boolean ended</dt>

            <dd>
              <p>The <dfn id="dom-mediastream-ended">
                  <code>MediaStream.ended</code>
                </dfn> attribute MUST return true if the <code>
                  <a>MediaStream</a>
                </code> has <a>finished</a>, and false otherwise.</p>

              <p>When a <code>
                  <a>MediaStream</a>
                </code> object is created, its <code>
                  <a href="#dom-mediastream-ended">ended</a>
                </code> attribute MUST be set to false, unless it is being
              created using the <code>
                  <a href="#dom-mediastream">MediaStream()</a>
                </code> constructor whose arguments are lists of <code>
                  <a>MediaStreamTrack</a>
                </code> objects that are all <a>ended</a>, in which case the
              <code>
                  <a>MediaStream</a>
                </code> object MUST be created with its <code>
                  <a href="#dom-mediastream-ended">ended</a>
                </code> attribute set to true.</p>
            </dd>

            <dt>attribute Function? onended</dt>

            <dd>This event handler, of type <code>
                <a href="#event-mediastream-ended">ended</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>MediaStream</a>
              </code> interface.</dd>
          </dl>

          <div class="idl" title="MediaStream implements EventTarget" />
        </section>

        <section>
          <h4>LocalMediaStream</h4>

          <p>Before the web application can access the users media input
          devices it must let <code>getUserMedia()</code> [[!GETUSERMEDIA]]
          create a <code>
              <a>LocalMediaStream</a>
            </code>. Once the application is done using, e.g., a webcam and a
          microphone, it may revoke its own access by calling <code>
              <a href="#dom-mediastream-stop">stop()</a>
            </code> on the <code>
              <a>LocalMediaStream</a>
            </code>. <!--If the web application no longer has access to any media input devices, any
 "on air" indicators in the browser UI MUST be turned off.--></p>

          <p>A web application may, once it has access to a <code>
              <a>LocalMediaStream</a>
            </code>, use the <code>
              <a href="#dom-mediastream">MediaStream()</a>
            </code> constructor to construct additional <code>
              <a>MediaStream</a>
            </code> objects. Since a derived <code>
              <a>MediaStream</a>
            </code> object is created from the tracks of an existing stream,
          it cannot use any media input devices that have not been approved by
          the user.</p>

          <dl class="idl" title="interface LocalMediaStream : MediaStream">
            <dt>void stop()</dt>

            <dd>
              <p>When a <code>
                  <a>LocalMediaStream</a>
                </code> object's <dfn id="dom-mediastream-stop">
                  <code>stop()</code>
                </dfn> method is invoked, the user agent MUST queue a task
              that runs the following steps on every track:</p>

              <ol>
                <li>
                  <p>Let <var>track</var> be the current <code>
                      <a>MediaStreamTrack</a>
                    </code> object.</p>
                </li>

                <li>
                  <p><a title="ended">End</a> <var>track</var>. The track
                  start outputting only silence and/or blackness, as
                  appropriate.</p>
                </li>

                <li>
                  <p>Dereference <var>track's</var> underlying media
                  source.</p>
                </li>

                <li>
                  <p>If the reference count of <var>track's</var> underlying
                  media source is greater than zero, then abort these
                  steps.</p>
                </li>

                <li>
                  <p>Permanently stop the generation of data for
                  <var>track's</var> source. If the data is being generated
                  from a live source (e.g. a microphone or camera), then the
                  user agent SHOULD remove any active "on-air" indicator for
                  that source. If the data is being generated from a
                  prerecorded source (e.g. a video file), any remaining
                  content in the file is ignored.</p>
                </li>
              </ol>

              <p>The task source for the <span
              title="concept-task">tasks</span> queued for the <code>
                  <a href="#dom-mediastream-stop">stop()</a>
                </code> method is the DOM manipulation task source.</p>
            </dd>
          </dl>
        </section>

        <section>
          <h4>MediaStreamTrack</h4>

          <p>A <code>
              <a>MediaStreamTrack</a>
            </code> object represents a media source in the user agent.
          Several <code>
              <a>MediaStreamTrack</a>
            </code> objects can represent the same media source, e.g., when
          the user chooses the same camera in the UI shown by two consecutive
          calls to <code>getUserMedia()</code> [[!GETUSERMEDIA]].</p>

          <p>A <code>
              <a>MediaStreamTrack</a>
            </code> object can reference its media source in two ways, either
          with a strong or a weak reference, depending on how the track was
          created. For example, a track in a <code>
              <a>MediaStream</a>
            </code>, derived from a <code>
              <a>LocalMediaStream</a>
            </code> with the <code>
              <a href="#dom-mediastream">MediaStream()</a>
            </code> constructor, has a weak reference to a local media source,
          while a track in a <code>
              <a>LocalMediaStream</a>
            </code> has a strong reference. This means that a track in a <code>
              <a>MediaStream</a>
            </code>, derived from a <code>
              <a>LocalMediaStream</a>
            </code>, will end if there is no non-<a>ended</a> track in a <code>
              <a>LocalMediaStream</a>
            </code> which references the same local media source. A reference
          to a non-local media source as, e.g., an RTP source, is always
          strong.</p>

          <p class="note">The concept with strong and weak references to media
          sources allows the web application to derive new <code>
              <a>MediaStream</a>
            </code> objects from <code>
              <a>LocalMediaStream</a>
            </code> objects (created via <code>getUserMedia()</code>
          [[!GETUSERMEDIA]]), and still be able to revoke all given
          permissions with <code>
              <a href="#dom-mediastream-stop">LocalMediaStream.stop()</a>
            </code>.</p>

          <p>A <code>
              <a>MediaStreamTrack</a>
            </code> object is said to <em>end</em> when the user agent learns
          that no more data will ever be forthcoming for this track.</p>

          <p>When a <code>
              <a>MediaStreamTrack</a>
            </code> object ends for any reason (e.g. because the user rescinds
          the permission for the page to use the local camera, or because the
          data comes from a finite file and the file's end has been reached
          and the user has not requested that it be looped, or because the
          track belongs to a <code>
              <a>MediaStream</a>
            </code> that comes from a remote peer and the remote peer has
          permanently stopped sending data, or because the UA has instructed
          the track to end for any reason, or because the reference count of
          the track's underlying media source has reached zero, it is said to
          be <dfn>ended</dfn>. When track instance <var>track</var> ends for
          any reason other than <code>
              <a href="#dom-mediastream-stop">stop()</a>
            </code> method being invoked on the <code>
              <a>LocalMediaStream</a>
            </code> object that represents <var>track</var>, the user agent
          MUST queue a task that runs the following steps:</p>

          <ol>
            <li>
              <p>If the track's <code>
                  <a href="#dom-mediastreamtrack-readystate">readyState</a>
                </code> attribute has the value <code>
                  <a href="#widl-MediaStreamTrack-ENDED">ENDED</a>
                </code> (2) already, then abort these steps.</p>
            </li>

            <li>
              <p>Set <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-readystate">readyState</a>
                </code> attribute to <code>
                  <a href="#widl-MediaStreamTrack-ENDED">ENDED</a>
                </code> (2).</p>
            </li>

            <li>
              <p>Fire a simple event named <code>
                  <a href="#event-mediastreamtrack-ended">ended</a>
                </code> at the object.</p>
            </li>
          </ol>

          <dl class="idl" title="interface MediaStreamTrack">
            <dt>readonly attribute DOMString kind</dt>

            <dd>
              <p>The <dfn id="dom-mediastreamtrack-kind">
                  <code>MediaStreamTrack.kind</code>
                </dfn> attribute MUST return the string "<code>audio</code>"
              if the object's corresponding track is or was an audio track,
              "<code>video</code>" if the corresponding track is or was a
              video track, and a user-agent defined string otherwise.</p>
            </dd>

            <dt>readonly attribute DOMString label</dt>

            <dd>
              <p class="note"> TODO - note - do we need the label from a
              Stream here. Do these labels need to be globally unique. If not
              what is the name scoping </p>

              <p>User agents MAY label audio and video sources (e.g. "Internal
              microphone" or "External USB Webcam"). The <dfn
                  id="dom-mediastreamtrack-label">
                  <code>MediaStreamTrack.label</code>
                </dfn> attribute MUST return the label of the object's
              corresponding track, if any. If the corresponding track has or
              had no label, the attribute MUST instead return the empty
              string.</p>

              <p class="note">Thus the <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> and <code title="dom-MediaStreamTrack-label">
                  <a href="#dom-mediastreamtrack-label">label</a>
                </code> attributes do not change value, even if the <code>
                  <a>MediaStreamTrack</a>
                </code> object is disassociated from its corresponding
              track.</p>
            </dd>

            <dt>attribute boolean enabled</dt>

            <dd>
              <p>The <dfn id="dom-mediastreamtrack-enabled">
                  <code>MediaStreamTrack.enabled</code>
                </dfn> attribute, on getting, MUST return the last value to
              which it was set. On setting, it MUST be set to the new value,
              and then, if the <code>
                  <a>MediaStreamTrack</a>
                </code> object is still associated with a track, MUST enable
              the track if the new value is true, and disable it
              otherwise.</p>

              <p class="note">Thus, after a <code>
                  <a>MediaStreamTrack</a>
                </code> is disassociated from its track, its <code>
                  <a href="#dom-mediastreamtrack-enabled">enabled</a>
                </code> attribute still changes value when set, it just
              doesn't do anything with that new value.</p>
            </dd>

            <dt>const unsigned short LIVE = 0</dt>

            <dd>
              <p>The track is active (the track's underlying media source is
              making a best-effort attempt to provide data in real time).</p>

              <p>The output of a track in the <code>
                  <a href="#widl-MediaStreamTrack-LIVE">LIVE</a>
                </code> state can be switched on and off with the <code>
                  <a href="#dom-mediastreamtrack-enabled">enabled</a>
                </code> attribute.</p>
            </dd>

            <dt>const unsigned short MUTED = 1</dt>

            <dd>
              <p>The track is muted (the track's underlying media source is
              temporarily unable to provide data).</p>

              <p>For example, a track is muted on the B-side if the A-side
              disables the corresponding <code>
                  <a>MediaStreamTrack</a>
                </code> in the <code>
                  <a>MediaStream</a>
                </code> that is being sent. A <code>
                  <a>MediaStreamTrack</a>
                </code> in a <code>
                  <a>LocalMediaStream</a>
                </code> may be muted if the user temporarily revokes the web
              application's permission to use a media input device.</p>

              <p>When the addstream event triggers on a <code>
                  <a>PeerConnection</a>
                </code>, all <code>
                  <a>MediaStreamTrack</a>
                </code> objects in the resulting <code>
                  <a>MediaStream</a>
                </code> are muted until media data can be read from the RTP
              source.</p>
            </dd>

            <dt>const unsigned short ENDED = 2</dt>

            <dd>
              <p>The track has <a>ended</a> (the track's underlying media
              source is no longer providing data, and will never provide more
              data for this track).</p>

              <p>For example, a video track in a <code>
                  <a>LocalMediaStream</a>
                </code> finishes if the user unplugs the USB web camera that
              acts as the track's media source.</p>
            </dd>

            <dt>readonly attribute unsigned short readyState</dt>

            <dd>
              <p>The <dfn id="dom-mediastreamtrack-readystate">
                  <code>readyState</code>
                </dfn> attribute represents the state of the track. It MUST
              return the value to which the user agent last set it (as defined
              below). It can have the following values: <dfn>LIVE</dfn>,
              <dfn>MUTED</dfn> or <dfn>ENDED</dfn>.</p>

              <p>When a <code>
                  <a>MediaStreamTrack</a>
                </code> object is created, its <code>
                  <a href="#dom-mediastreamtrack-readystate">readyState</a>
                </code> is either <code>
                  <a href="#widl-MediaStreamTrack-LIVE">LIVE</a>
                </code> (0) or <code>
                  <a href="#widl-MediaStreamTrack-MUTED">MUTED</a>
                </code> (1), depending on the state of the track's underlying
              media source. For example, a track in a <code>
                  <a>LocalMediaStream</a>
                </code>, created with <code>getUserMedia()</code>
              [[!GETUSERMEDIA]] , MUST initially have its <code>
                  <a href="#dom-mediastreamtrack-readystate">readyState</a>
                </code>attribute set to <code>
                  <a href="#widl-MediaStreamTrack-LIVE">LIVE</a>
                </code> (1), while a track in a <code>
                  <a>MediaStream</a>
                </code>, received with a <code>
                  <a>PeerConnection</a>
                </code>, MUST have its <code>
                  <a href="#dom-mediastreamtrack-readystate">readyState</a>
                </code> attribute set to <code>
                  <a href="#widl-MediaStreamTrack-MUTED">MUTED</a>
                </code> (1) until media data arrives.</p>
            </dd>

            <dt>attribute Function? onmute</dt>

            <dd>This event handler, of type <code>
                <a href="#event-mediastreamtrack-muted">muted</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>MediaStreamTrack</a>
              </code> interface.</dd>

            <dt>attribute Function? onunmute</dt>

            <dd>This event handler, of type <code>
                <a href="#event-mediastreamtrack-unmuted">unmuted</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>MediaStreamTrack</a>
              </code> interface.</dd>

            <dt>attribute Function? onended</dt>

            <dd>This event handler, of type <code>
                <a href="#event-mediastreamtrack-ended">ended</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>MediaStreamTrack</a>
              </code> interface.</dd>
          </dl>
        </section>

        <section>
          <h4>AudioMediaStreamTrack</h4>

          <p>The <code>
              <a>AudioMediaStreamTrack</a>
            </code> is a specialization of a normal <code>
              <a>MediaStreamTrack</a>
            </code> that only carries audio and is extended to have the
          capability to send and/or receive DTMF codes.</p>

          <dl class="idl"
              title="interface AudioMediaStreamTrack : MediaStreamTrack">
            <dt>readonly attribute boolean canInsertDTMF</dt>

            <dd>
              <p>The <dfn id="dom-audiomediastreamtrack-caninsertdtmf">
                  <code>canInsertDTMF</code>
                </dfn> attribute MUST indicate if the <code>
                  <a>AudioMediaStreamTrack</a>
                </code> is capable of sending DTMF. </p>
            </dd>

            <dt>void insertDTMF(in DOMString tones, optional long
            duration)</dt>

            <dd>
              <p> When a <code>
                  <a>AudioMediaStreamTrack</a>
                </code> object's <dfn
                  id="dom-AudioMediaStreamTrack-insertDTMF">
                  <code>insertDTMF()</code>
                </dfn> method is invoked, the user agent MUST queue a task
              that sends the DTMF tones. </p>

              <p> The tone parameters is treated as a series of characters.
              The characters 0 to 9, A to D, #, and * generated the associated
              DTMF tones. The characters a to d are equivalent to A to D. The
              character , indicates a an delay of 2 seconds before processing
              the next character in the tones parameter. Unrecognized
              characters are ignored. </p>

              <p> The duration parameters indicates the duration in ms to play
              the each DTMF passed in the tones parameters. The duration can
              not be more than 6000 or less than 70. The default duration is
              100 ms for each tone. The gap between tones MUST be at least 50
              ms but should be as short as possible. </p>

              <p> If insertDTMF is called on the same object while an existing
              task for this object is generate DTMF is still running, the
              previous task is canceled. Calling insertDTMF with an empty
              tones parameter can be used to cancel any tones currently being
              send. </p>

              <p class="note"> Editor Note: We need to add a callback that is
              set on the object that is called after the tones are sent. This
              is needed to allow the application to know when it can send new
              tones without canceling the tones that are currently being sent.
              </p>

              <p class="note"> Editor Note: It seems we would want a callback
              or event for incoming tones. The proposal sent to the list had
              them played as audio to the speaker but I don't see how that is
              useful. </p>
            </dd>
          </dl>
        </section>

        <section>
          <h4>MediaStreamTrackList</h4>

          <p>A <code>
              <a>MediaStreamTrackList</a>
            </code> object's <dfn
          id="concept-track-list-corresponding-stream">corresponding</dfn>
          <code>
              <a>MediaStream</a>
            </code> refers to the <code>
              <a>MediaStream</a>
            </code> object which the current <code>
              <a>MediaStreamTrackList</a>
            </code> object is a property of.</p>

          <dl class="idl" title="interface MediaStreamTrackList">
            <dt>readonly attribute unsigned long length</dt>

            <dd>Returns the number of tracks in the list.</dd>

            <!-- FIXME: getter syntax doesn't seem to be supported by respec -->

            <dt>MediaStreamTrack item(unsigned long index)</dt>

            <dd>Returns the <code>
                <a>MediaStreamTrack</a>
              </code> object at the specified index.</dd>

            <dt>void add(MediaStreamTrack track)</dt>

            <dd>
              <p>Adds the given <code>
                  <a>MediaStreamTrack</a>
                </code> to this <code>
                  <a>MediaStreamTrackList</a>
                </code> according to the ordering rules for tracks.</p>

              <p>When the <dfn id="dom-mediastreamtracklist-add">
                  <code>add()</code>
                </dfn> method is invoked, the user agent MUST run the
              following steps:</p>

              <ol>
                <li>
                  <p>Let <var>track</var> be the <code>
                      <a>MediaStreamTrack</a>
                    </code> argument.</p>
                </li>

                <li>
                  <p>Let <var>stream</var> be the <code>
                      <a>MediaStreamTrackList</a>
                    </code> object's <a
                  href="#concept-track-list-corresponding-stream"
                  title="concept-track-list-corresponding-stream">corresponding</a>
                  <code>
                      <a>MediaStream</a>
                    </code> object.</p>
                </li>

                <li>
                  <p>If <var>stream</var> is <a>finished</a>, throw an
                  <code>INVALID_STATE_ERR</code> exception.</p>
                </li>

                <li>
                  <p>If <var>track</var> is already in the <code>
                      <a>MediaStreamTrackList</a>
                    </code>, object's internal list, then abort these
                  steps.</p>
                </li>

                <li>
                  <p>Add <var>track</var> to the end of the <code>
                      <a>MediaStreamTrackList</a>
                    </code> object's internal list.</p>
                </li>
              </ol>
            </dd>

            <dt>void remove(MediaStreamTrack track)</dt>

            <dd>
              <p>Removes the given <code>
                  <a>MediaStreamTrack</a>
                </code> from this <code>
                  <a>MediaStreamTrackList</a>
                </code>.</p>

              <p>When the <dfn id="dom-mediastreamtracklist-remove">
                  <code>remove()</code>
                </dfn> method is invoked, the user agent MUST run the
              following steps:</p>

              <ol>
                <li>
                  <p>Let <var>track</var> be the <code>
                      <a>MediaStreamTrack</a>
                    </code> argument.</p>
                </li>

                <li>
                  <p>Let <var>stream</var> be the <code>
                      <a>MediaStreamTrackList</a>
                    </code> object's <a
                  href="#concept-track-list-corresponding-stream"
                  title="concept-track-list-corresponding-stream">corresponding</a>
                  <code>
                      <a>MediaStream</a>
                    </code> object.</p>
                </li>

                <li>
                  <p>If <var>stream</var> is <a>finished</a>, throw an
                  <code>INVALID_STATE_ERR</code> exception.</p>
                </li>

                <li>
                  <p>If <var>track</var> is not in the <code>
                      <a>MediaStreamTrackList</a>
                    </code>, object's internal list, then abort these
                  steps.</p>
                </li>

                <li>
                  <p>Remove <var>track</var> from the <code>
                      <a>MediaStreamTrackList</a>
                    </code> object's internal list.</p>
                </li>
              </ol>
            </dd>

            <dt>attribute Function? onaddtrack</dt>

            <dd>This event handler, of type <code>
                <a href="#event-mediastreamtracklist-addtrack">addtrack</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>MediaStreamTrackList</a>
              </code> interface.</dd>

            <dt>attribute Function? onremovetrack</dt>

            <dd>This event handler, of type <code>
                <a
                href="#event-mediastreamtracklist-removetrack">removetrack</a>
              </code>, MUST be supported by all objects implementing the <code>
                <a>MediaStreamTrackList</a>
              </code> interface.</dd>
          </dl>
        </section>

        <section>
          <h4>MediaStreamRecorder</h4>

          <p class="note">The <code>
              <a>MediaStreamRecorder</a>
            </code> needs to be able to handle the case that arises when
          changes are made to the <code>
              <a>MediaStreamTrackList</a>
            </code> objects of the <code>
              <a>MediaStream</a>
            </code> being recorded; e.g., a new track is added as a result of
          the <code>
              <a href="#dom-mediastreamtracklist-add">add()</a>
            </code> method being invoked.</p>

          <dl class="idl" title="interface MediaStreamRecorder">
            <dt>voice getRecordedData (BlobCallback? callBack)</dt>

            <dd>
              <p>Creates a <code>Blob</code> of the recorded data, and invokes
              the provided callback with that <code>Blob</code>.</p>

              <p>When the <dfn id="dom-mediastreamrecorder-getrecordeddata">
                  <code>getRecordedData()</code>
                </dfn> method is called, the user agent MUST run the following
              steps:</p>

              <ol>
                <li>
                  <p>Let <var>callBack</var> be the callback indicated by the
                  method's first argument.</p>
                </li>

                <li>
                  <p>If <var>callBack</var> is null, abort these steps.</p>
                </li>

                <!-- we could throw an exception instead (that's
   why the method doesn't return until later: so that we can add an
   exception here without changing the algorithm) -->

                <li>
                  <p>Let <var>data</var> be the data that was streamed by the
                  <code>
                      <a>MediaStream</a>
                    </code> object from which the <code>
                      <a>MediaStreamRecorder</a>
                    </code> was created since the creation of the <code>
                      <a>MediaStreamRecorder</a>
                    </code> object.</p>
                </li>

                <li>
                  <p>Return, and run the remaining steps asynchronously.</p>
                </li>

                <li>
                  <p>Generate a file that containing <var>data</var> in a
                  format supported by the user agent for use in
                  <code>audio</code> and <code>video</code> elements.</p>
                </li>

                <li>
                  <p>Let <var>blob</var> be a <code>Blob</code> object
                  representing the contents of the file generated in the
                  previous step. [[!FILE-API]]</p>
                </li>

                <li>
                  <p>Queue a task to invoke <var>callBack</var> with
                  <var>blob</var> as its argument.</p>
                </li>
              </ol>

              <p class="note">The <code>
                  <a
                  href="#dom-mediastreamrecorder-getrecordeddata">getRecordedData()</a>
                </code> method can be called multiple times on one <code>
                  <a>MediaStreamRecorder</a>
                </code> object; each time, it will create a new file as if
              this was the first time the method was being called. In
              particular, the method does not stop or reset the recording when
              the method is called.</p>
            </dd>
          </dl>
        </section>

        <section>
          <h4>BlobCallback</h4>

          <dl class="idl"
              title="[Callback, NoInterfaceObject] interface BlobCallback">
            <dt>void handleEvent (Blob blob)</dt>

            <dd>Def TBD</dd>
          </dl>
        </section>

        <section>
          <h4>URL</h4>

          <dl class="idl" title="partial interface URL">
            <dt>static DOMString createObjectURL (MediaStream stream)</dt>

            <dd>
              <p>Mints a <a href="#blob-url">Blob URL</a> to refer to the
              given <code>
                  <a>MediaStream</a>
                </code>.</p>

              <p>When the <dfn id="dom-url-createobjecturl">
                  <code>createObjectURL()</code>
                </dfn> method is called with a <code>
                  <a>MediaStream</a>
                </code> argument, the user agent MUST return a unique <a
              href="#blob-url">Blob URL</a> for the given <code>
                  <a>MediaStream</a>
                </code>. [[!FILE-API]]</p>

              <p>For audio and video streams, the data exposed on that stream
              MUST be in a format supported by the user agent for use in
              <code>audio</code> and <code>video</code> elements.</p>

              <p class="bookkeeping">A <dfn id="blob-url">Blob URL</dfn> is
              the same as what the File API specification calls a Blob URI,
              except that anything in the definition of that feature that
              refers to <code>File</code> and <code>Blob</code> objects is
              hereby extended to also apply to <code>
                  <a>MediaStream</a>
                </code> and <code>
                  <a>LocalMediaStream</a>
                </code> objects.</p>
            </dd>
          </dl>
        </section>
      </section>

      <!--
      <section>
        <h3>Examples</h3>

          <p> TOOD - redo the examples. </p>         
      </section>
          -->
    </section>

    <section>
      <h2>Peer-to-peer connections</h2>

      <!-- ==================================================================== -->

      <p>A <code>
          <a>PeerConnection</a>
        </code> allows two users to communicate directly, browser to browser.
      Communications are coordinated via a signaling channel provided by
      script in the page via the server, e.g. using
      <code>XMLHttpRequest</code>.</p>

      <p>Calling <code>new <a>PeerConnection</a>(<var>configuration</var>
      )</code> creates a <code>
          <a>PeerConnection</a>
        </code> object.</p>

      <p>The <var>configuration</var> is a array of pairs where each pair is
      an array where the first element is a stun or turn URIs as defined in
      [[!STUN-URI]] and [[!TURN-URI]]. The if the first element of the pair is
      TURN URI, then the second element of the pair is the credential to use
      with that TURN server. This configuration array give the addresses of
      STUN and TURN server to use to establish the connection. [[!STUN]]
      [[!TURN]]</p>

      <p>An example configuration array is:</p>

      <dl>
        <dt>
          <code>[ ["stun:stun.example.org"] ,
          ["turn:user@turn.example.org","myPassword"] ]</code>
        </dt>
      </dl>

      <p>A <code>
          <a>PeerConnection</a>
        </code> object has an associated a <dfn
      id="peerconnection-ice-agent"><code>PeerConnection</code> ICE
      Agent</dfn>, and a <dfn
      id="peerconnection-readiness-state"><code>PeerConnection</code>
      readiness state</dfn>. These are initialized when the object is
      created.</p>

      <p>When the <dfn id="dom-peerconnection">
          <code>PeerConnection()</code>
        </dfn> constructor is invoked, the user agent MUST run the following
      steps. This algorithm has a synchronous section (which is triggered as
      part of the event loop algorithm). Steps in the synchronous section are
      marked with ⌛.</p>

      <ol>
        <li>
          <p>Create an ICE Agent and let <var>connection</var>’s <a
          href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
          Agent</a> be that ICE Agent and provide it the STUN and TURN servers
          from the configuration array. [[!ICE]]</p>
        </li>

        <li>
          <p>Set <var>connection</var>’s <a
          href="#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a> to <code>
              <a href="#widl-PeerConnection-NEW">NEW</a>
            </code> (0).</p>
        </li>

        <li>
          <p>Set <var>connection</var>’s <a
          href="#peerconnection-readiness-state"><code>PeerConnection</code>
          ice state </a> to <code>
              <a href="#widl-PeerConnection-NEW">NEW</a>
            </code> (0).</p>
        </li>

        <li>
          <p>Let <var>connection</var>’s <code
              title="dom-PeerConnection-localStreams">
              <a href="#widl-PeerConnection-localStreams">localStreams</a>
            </code> attribute be an empty read-only <code>
              <a>MediaStream</a>
            </code> array. </p>
        </li>

        <li>
          <p>Let <var>connection</var>’s <code
              title="dom-PeerConnection-remoteStreams">
              <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
            </code> attribute be an empty read-only <code>
              <a>MediaStream</a>
            </code> array. </p>
        </li>

        <li>
          <p>Return <var>connection</var>, but continue these steps
          asynchronously.</p>
        </li>

        <li>
          <p>Await a stable state. The synchronous section consists of the
          remaining steps of this algorithm. </p>
        </li>

        <li>
          <p>If the ice state is set to NEW, it MUST queue a task to start
          gathering ICE address and set the ice state to ICE_GATHERING.</p>
        </li>
      </ol>

      <p> During the lifetime of the PeerConnection object, the following
      procedures are followed: </p>

      <ol>
        <li>
          <p> If the ICE Agent finds a candidates that forms a valid
          connection, the ICE state is changed to ICE_CONNECTED </p>
        </li>

        <li>
          <p> If the ICE Agent finishes checking all candidates, if a
          connection has been found, the ice state is changed to ICE_COMPLETED
          and if not connection has been found it is changed to ICE_FAILED.
          </p>
        </li>

        <li>
          <p> If the iceState is ICE_CONNECTED or ICE_COMPLETED and the SDP
          stat is SDP_IDLE, the readyState is set to ACTIVE. </p>
        </li>

        <li>
          <p> If the iceState is ICE_FAILED, a task is queued to calls the
          close method. </p>
        </li>

        <li>
          <p> The close method will stop all ICE process and change the
          iceState to ICE_CLOSED. </p>
        </li>
      </ol>

      <!-- TODO here forward -->

      <p>User agents MAY negotiate any codec and any resolution, bitrate, or
      other quality metric. User agents are encouraged to initially negotiate
      for the native resolution of the stream. For streams that are then
      rendered (using a <code>video</code> element), user agents are
      encouraged to renegotiate for a resolution that matches the rendered
      display size.</p>

      <p class="note">Starting with the native resolution means that if the
      Web application notifies its peer of the native resolution as it starts
      sending data, and the peer prepares its <code>video</code> element
      accordingly, there will be no need for a renegotiation once the stream
      is flowing.</p>

      <p>All SDP media descriptions for streams represented by <code>
          <a>MediaStream</a>
        </code> objects MUST include a label attribute ("<code
      title="">a=label:</code>") whose value is the value of the <code>
          <a>MediaStream</a>
        </code> object's <code title="dom-MediaStream-label">
          <a href="#dom-mediastream-label">label</a>
        </code> attribute. [[!SDP]] [[!SDPLABEL]]</p>

      <p><a href="#peerconnection"><code>PeerConnection</code>s</a> MUST not
      generate any candidates for media streams whose media descriptions do
      not have a label attribute ("<code>a=label:</code>"). [[!ICE]] [[!SDP]]
      [[!SDPLABEL]]</p>

      <p>When a user agent has reached the point in the media negotiation
      where a <code>
          <a>MediaStream</a>
        </code> can be created to represent incoming components, the user
      agent MUST run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>connection</var> be the <code>
              <a>PeerConnection</a>
            </code> expecting this media.</p>
        </li>

        <li>
          <p>Create a <code>
              <a>MediaStream</a>
            </code> object to represent the media stream. Set its <code>
              <a href="#dom-mediastream-label">label</a>
            </code> attribute to the value of the SDP Label attribute for that
          component's media stream.</p>
        </li>

        <li>
          <p>Run the following steps for each component in the media
          stream.</p>

          <ol>
            <li>
              <p>Create a <code>
                  <a>MediaStreamTrack</a>
                </code> object <var>track</var> to represent the
              component.</p>
            </li>

            <li>
              <p>If <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> attribute equals "<code>audio</code>", add it to the
              <code>
                  <a>MediaStream</a>
                </code> object's <code>
                  <a href="#dom-mediastream-audiotracks">audioTracks</a>
                </code> <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>

            <li>
              <p>If <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> attribute equals "<code>video</code>", add it to the
              <code>
                  <a>MediaStream</a>
                </code> object's <code>
                  <a href="#dom-mediastream-videotracks">videoTracks</a>
                </code> <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>
          </ol>

          <p class="note">The internal order in the <code>
              <a>MediaStreamTrackList</a>
            </code> objects on the receiving side should reflect the order on
          the sending side. One way to enforce this is to specify the order in
          the SDP.</p>
        </li>

        <li>
          <p>Queue a task to run the following substeps:</p>

          <ol>
            <li>
              <p>If the <var>connection</var>’s <a
              href="#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code>
                  <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                </code> (3), abort these steps.</p>
            </li>

            <!-- close() was probably called just before this
     task ran -->

            <li>
              <p>Add the newly created <code>
                  <a>MediaStream</a>
                </code> object to the end of <var>connection</var>’s <code
                  title="dom-PeerConnection-remoteStreams">
                  <a
                  href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
                </code> array.</p>
            </li>

            <li>
              <p><a href="#fire-a-stream-event">Fire a stream event</a> named
              <code title="event-MediaStream-addstream">
                  <a href="#event-mediastream-addstream">addstream</a>
                </code> with the newly created <code>
                  <a>MediaStream</a>
                </code> object at the <var title="">connection</var>
              object.</p>
            </li>
          </ol>
        </li>
      </ol>

      <p>When a user agent has negotiated media for a component that belongs
      to a media stream that is already represented by an existing <code>
          <a>MediaStream</a>
        </code> object, the user agent MUST associate the component with that
      <code>
          <a>MediaStream</a>
        </code> object.</p>

      <p>When a <a href="#peerconnection">
          <code>PeerConnection</code>
        </a> finds that a stream from the remote peer has been removed (its
      port has been set to zero in a media description sent on the signaling
      channel), the user agent MUST follow these steps:</p>

      <ol>
        <li>
          <p>Let <var>connection</var> be the <code>
              <a>PeerConnection</a>
            </code> associated with the stream being removed.</p>
        </li>

        <li>
          <p>Let <var>stream</var> be the <code>
              <a>MediaStream</a>
            </code> object that represents the media stream being removed, if
          any. If there isn't one, then abort these steps.</p>
        </li>

        <li>
          <p>By definition, <var>stream</var> is now <a>finished</a>.</p>

          <p class="note">A <span title="concept-task">task</span> is thus
          <span title="queue a task">queued</span> to update <var>stream</var>
          and fire an event.</p>
        </li>

        <li>
          <p>Queue a task to run the following substeps:</p>

          <ol>
            <li>
              <p>If the <var>connection</var>’s <a
              href="#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code>
                  <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                </code> (3), abort these steps.</p>
            </li>

            <!-- close() was probably called just before this
     task ran -->

            <li>
              <p>Remove <var>stream</var> from <var>connection</var>’s <code>
                  <a
                  href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
                </code> array.</p>
            </li>

            <li>
              <p><a href="#fire-a-stream-event">Fire a stream event</a> named
              <code title="event-MediaStream-removestream">
                  <a href="#event-mediastream-removestream">removestream</a>
                </code> with <var title="">stream</var> at the
              <var>connection</var> object.</p>
            </li>
          </ol>
        </li>
      </ol>

      <p>The task source for the <span title="concept-task">tasks</span>
      listed in this section is the networking task source.</p>

      <p>If a <code>
          <a>PeerConnection</a>
        </code> object is <a title="consumer">consuming</a> a <code>
          <a>MediaStream</a>
        </code> and a track is added to one of the stream's <code>
          <a>MediaStreamTrackList</a>
        </code> objects, by, e.g., the <code>
          <a href="#dom-mediastreamtracklist-add">add()</a>
        </code> method being invoked, the <code>
          <a>PeerConnection</a>
        </code> object MUST add a media component for that track the next time
      the user agent <span title="provide a stable   state">provides a stable
      state</span>. The user agent MUST also remove a media component in same
      way.</p>

      <p class="warning">To prevent network sniffing from allowing a fourth
      party to establish a connection to a peer using the information sent
      out-of-band to the other peer and thus spoofing the client, the
      configuration information SHOULD always be transmitted using an
      encrypted connection.</p>

      <section>
        <h3>PeerConnection</h3>

        <p> The general operation of the PeerConnection is described in
        [[RTCWEB-JSEP]]. </p>

        <dt>typedef SdpType DomString; //enum SdpType { "offer", "pranswer",
        "answer" }</dt>

        <dd>
          <p> The SdpType enums serve as arguments to setLocalDescription and
          setRemoteDescription. They provide information as to how the SDP
          should be handled. </p>

          <dl>
            <dt>
              <code title="widl-SdpType-offer">
                <a href="#widl-SdpType-offer">"offer"</a>
              </code>
            </dt>

            <dd>
              <p> An SdpType of "offer" indicates that a description should be
              treated as an [[!SDP]] offer. A description used as a SDP offer
              may be applied anytime the PeerConnection is in a stable state,
              or as an update to a previously sent but unanswered SDP offer.
              <!-- TODO -READ THIS PARA --> </p>
            </dd>

            <dt>
              <code title="widl-SdpType-pranswer">
                <a href="#widl-SdpType-pranswer">"pranswer"</a>
              </code>
            </dt>

            <dd>
              <p> An SdpType of "pranswer" indicates that a description should
              be treated as an [[!SDP]] answer, but not a final answer. A
              description used as a SDP "pranswer" may be applied as a
              response to a SDP offer, or an update to a previously sent SDP
              "answer". </p>
            </dd>

            <dt>
              <code title="widl-SdpType-answer">
                <a href="#widl-SdpType-answer">"answer"</a>
              </code>
            </dt>

            <dd>
              <p> An SdpType of "answer" indicates that a description should
              be treated as an [[!SDP]] final answer, and the offer-answer
              exchange should be considered complete. A description used as a
              SDP answer may be applied as a response to a SDP offer, or an
              update to a previously send SDP "pranswer". </p>
            </dd>
          </dl>
        </dd>

        <dt>typedef PeerState DomString; //enum PeerState { "new" "opening",
        "active", "closing", "closed" }</dt>

        <dd>
          <dl>
            <dt>
              <code title="widl-PeerConnection-NEW">
                <a href="#widl-PeerConnection-NEW">"new"</a>
              </code>
            </dt>

            <dd>The object was just created, and no networking has yet
            occurred.</dd>

            <dt>
              <code title="dom-PeerConnection-NEGOTIATING">
                <a href="#widl-PeerConnection-OPENING">"opening"</a>
              </code>
            </dt>

            <dd>The user agent is attempting to establish an connection with
            the ICE Agent and waiting for local and remote SDP to be set.
            </dd>

            <dt>
              <code title="dom-PeerConnection-ACTIVE">
                <a href="#widl-PeerConnection-ACTIVE">"active"</a>
              </code>
            </dt>

            <dd>The ICE Agent has found a connection both the local and remote
            SDP have been set. It is possible for media to flow. </dd>

            <dt>
              <code title="dom-PeerConnection-CLOSING">
                <a href="#widl-PeerConnection-CLOSED">"closing"</a>
              </code>
            </dt>

            <dd> The <code>
                <a>PeerConnection</a>
              </code> object is terminating all media and is in the process of
            closing the connection. </dd>

            <dt>
              <code title="dom-PeerConnection-CLOSED">
                <a href="#widl-PeerConnection-CLOSED">"closed"</a>
              </code>
            </dt>

            <dd>The connection is closed. </dd>
          </dl>
        </dd>

        <dt>typedef IceState DomString; //enum IceState { "new" "gathering",
        "waiting", "checking", "connected", "completed","failed", "closed"
        }</dt>

        <dd>
          <p>The IceState can take the following values:  </p>

          <dl>
            <dt>
              <code title="widl-PeerConnection-NEW">
                <a href="#widl-PeerConnection-NEW">"new"</a>
              </code>
            </dt>

            <dd>The PeerConnection object was just created, and no networking
            has yet occurred.</dd>

            <dt>
              <code title="dom-PeerConnection-GATHERING">
                <a href="#widl-PeerConnection-ICE_GATHERING">"gathering"</a>
              </code>
            </dt>

            <dd>The ICE Agent is attempting to gather addresses.</dd>

            <dt>
              <code title="dom-PeerConnection-ICE_WAITING">
                <a href="#widl-PeerConnection-ICE_WAITING">"waiting"</a>
              </code>
            </dt>

            <dd>The ICE Agent is not gathering any addresses and is waiting
            for candidates from the other side before it can start
            checking.</dd>

            <dt>
              <code title="dom-PeerConnection-CHECKING">
                <a href="#widl-PeerConnection-ACTIVE">"checking"</a>
              </code>
            </dt>

            <dd>The ICE Agent is checking candidates but has not yet found a
            connection.</dd>

            <dt>
              <code title="dom-PeerConnection-CONNECTED">
                <a href="#widl-PeerConnection-CLOSED">"connected"</a>
              </code>
            </dt>

            <dd>The ICE Agent has found a connection but is still checking
            other candidates to see if there is a better connection.</dd>

            <dt>
              <code title="dom-PeerConnection-COMPLETED">
                <a href="#widl-PeerConnection-CLOSED">"completed"</a>
              </code>
            </dt>

            <dd>The ICE Agent has finished checking and found a
            connection.</dd>

            <dt>
              <code title="dom-PeerConnection-ICE_FAILED">
                <a href="#widl-PeerConnection-CLOSED">"failed"</a>
              </code>
            </dt>

            <dd>The ICE Agent is finished checking all candidates and failed
            to find a connection.</dd>

            <dt>
              <code title="dom-PeerConnection-CLOSED">
                <a href="#widl-PeerConnection-CLOSED">"closed"</a>
              </code>
            </dt>

            <dd>The ICE Agent has shut down and is no longer responding to
            STUN requests.</dd>
          </dl>
        </dd>

        <dt>typedef Configuration DomString[][];</dt>

        <dd>
          <p>TODO </p>
        </dd>

        <dl class="idl"
            title="[Constructor (Configuration configuration)] interface PeerConnection">
          <dt>DOMString createAnswer (DOMString offer, optional
          MediaConstraints constraints)</dt>

          <dd>
            <p>The createAnswer method generates a [[!SDP]] answer with the
            supported configuration for the session that is compatible with
            the parameters supplied in offer. Like createOffer, the returned
            blob contains descriptions of the local MediaStreams attached to
            this PeerConnection, the codec/RTP/RTCP options negotiated for
            this session, and any candidates that have been gathered by the
            ICE Agent. The constraints parameter may be supplied to provide
            additional control over the generated answer. </p>

            <p> As an answer, the generated SDP will contain a specific
            configuration that specifies how the media plane should be
            established. For each SDP line, the generation of the SDP must
            follow the appropriate process for generating an answer. Session
            descriptions generated by createAnswer must be immediately usable by
            setLocalDescription without generating an error; like createOffer,
            the returned description should reflect the current state of the
            system. The session descriptions MUST remain usable by
            setLocalDescription without causing an error until at least the next
            time the user agent enter a stable state. Calling this method is is
            needed to get the ICE user name fragment and password.  </p>

            <p> A TBD exception is thrown if the constraints parameter is
            malformed, or the offer parameter is malformed. </p>
          </dd>

          <dt>DOMString createOffer (MediaConstraints constraints)</dt>

          <dd>
            <p> The createOffer method generates a blob of SDP that contains a
            RFC offer with the supported configurations for the session,
            including descriptions of the local MediaStreams attached to this
            PeerConnection, the codec/RTP/RTCP options supported by this
            implementation, and any candidates that have been gathered by the
            ICE Agent. The constraints parameter may be supplied to provide
            additional control over the offer generated. </p>

            <p> As an offer, the generated SDP will contain the full set of
            capabilities supported by the session (as opposed to an answer,
            which will include only a specific negotiated subset to use); for
            each SDP line, the generation of the SDP must follow the appropriate
            process for generating an offer. In the event createOffer is called
            after the session is established, createOffer will generate an offer
            that is compatible with the current session, incorporating any
            changes that have been made to the session since the last complete
            offer-answer exchange, such as addition or removal of streams. If no
            changes have been made, the offer will be include the capabilities
            of the current local description. </p>

            <p> Session descriptions generated by createOffer MUST be
            immediately usable by setLocalDescription without causing an error;
            if a system has limited resources (e.g. a finite number of
            decoders), createOffer should return an offer that reflects the
            current state of the system, so that setLocalDescription will
            succeed when it attempts to acquire those resources. The session
            descriptions MUST remain usable by setLocalDescription without
            causing an error until at least the next time the user agent enter a
            stable state. Calling this method is needed to get the ICE user name
            fragment and password. </p> </dd>

          <!-- TOOD move the Domstring with SDP to a type -->

          <dt>readonly attribute DOMString localDescription</dt>

          <dd>
            <p> The localDescription method returns a copy of the current
            local configuration, i.e. the answer that was most recently passed
            to setLocalDescription, plus any local candidates that have been
            generated by the ICE Agent since then. </p>

            <p> A null object will be returned if the local description has
            not yet been set with an answer. </p>
          </dd>

          <dt>void setLocalDescription (SdpType action, DOMString sdp)</dt>

          <dd>
            <p> The setLocalDescription method instructs the PeerConnection to
            apply the supplied [[!SDP]] blob as the local offer or answer. The
            type parameter indicates whether the blob should be processed as
            an offer, provisional answer, or final answer. </p>

            <p> This API changes the local media state; among other things, it
            sets up local resources for receiving and decoding media. In order
            to successfully handle scenarios where the application wants to
            offer to change from one media format to a different, incompatible
            format, the PeerConnection must be able to simultaneously support
            use of both the old and new local descriptions (e.g. support
            codecs that exist in both descriptions) until a final answer is
            received, at which point the PeerConnection can fully adopt the
            new local description, or roll back to the old description if the
            remote side denied the change. </p>

            <p>Changes to the state of media transmission will occur when
            a final answer is successfully applied. </p>

            <p> A TBD exception is thrown if sdp is invalid. A TBD exception
            is thrown if there are insufficient local resources to apply the
            sdp. </p>
          </dd>

          <dt>void setRemoteDescription (SdpType action, DOMString sdp)</dt>

          <dd>
            <p> The setRemoteDescription method instructs the PeerConnection
            to apply the supplied [[!SDP]]. As in setLocalDescription, the
            action parameter indicates how the blob should be processed. This
            API changes the local media state; among other things, it sets up
            local resources for sending and encoding media. </p>

            <p> Changes to the state of media transmission will occur
            when a final answer is successfully applied. </p>

            <p> A TBD exception is thrown if the sdp parameter is invalid. A
            TBD exception is thrown if there are insufficient local resources
            to apply the SDP. </p>
          </dd>

          <dt>readonly attribute DOMString remoteDescription</dt>

          <dd>
            <p> The remoteDescription method returns a copy of the current
            remote configuration, i.e. the answer that was most recently
            passed to setRemoteDescription, plus any remote candidates that
            have been supplied via addIceCandidate since then. </p>

            <p> A null object will be returned if the remote description has
            not yet been set with an answer. </p>
          </dd>

          <dt>readonly attribute PeerState readyState</dt>

          <dd>
            <p>The <dfn id="dom-peerconnection-readystate">
                <code title="">readyState</code>
              </dfn> attribute MUST return the <code>
                <a>PeerConnection</a>
              </code> object's <a
            href="#peerconnection-readiness-state"><code>PeerConnection</code>
            readiness state</a>. </p>
          </dd>

          <dt>void startIce (optional MediaConstraints constraints)</dt>

          <dd>
            <p> The startIce method starts or updates the ICE Agent process of
            gathering local candidates and pinging remote candidates. If there
            is a mandatory constraint called "media-enum-relay-only" and it is
            set to true, the ICE engine MUST only use candidates that are
            thought a relay servers such as a TURN server. This can be used to
            limit the use to TURN candidates by a callee to avoid leaking
            location information prior to the call being accepted. </p>

            <p> This call may result in a change to the state of the ICE
            Agent, and may result in a change to media state if it results in
            connectivity being established. </p>

            <p> A TBD exception will be thrown if constraints is malformed.
            </p>
          </dd>

          <dt>void addIceCandidate (IceCandidate candidate)</dt>

          <dd>
            <p>The addIceCandidate method provides a remote candidate to the
            ICE Agent, which will be added to the remote description. If
            startIce has been called, connectivity checks will be sent to the
            new candidates (as long as they would not be restricted by the
            "media-enum-relay-only" constraint. This call will result in a
            change to the state of the ICE Agent, and may result in a change
            to media state if it results in connectivity being established.
            </p>

            <p> The format of the candidate is TODO (same as line with ICE
            info in SDP) </p>

            <p> A TBD exception will be thrown if candidate parameter is
            malformed. </p>
          </dd>

          <dt>readonly attribute IceState iceState</dt>

          <dd>
            <p>The <dfn id="dom-peerconnection-icestate">
                <code>iceState</code>
              </dfn> attribute MUST return the state of the <a
            href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
            Agent</a> ICE state. </p>
          </dd>

          <dt>readonly attribute MediaStream[] localStreams</dt>

          <dd>
            <p>Returns a live array containing the local streams (those that
            were added with <code title="dom-PeerConnection-addStream">
                <a href="#dom-peerconnection-addstream">addStream()</a>
              </code>).</p>
          </dd>

          <dt>readonly attribute MediaStream[] remoteStreams</dt>

          <dd>
            <p>Returns a live array containing the streams that the remote
            streams. (those that were added by the remote side). </p>

            <p>This array is updated when <code>
                <a href="#event-mediastream-addstream">addstream</a>
              </code> and <code title="event-MediaStream-removestream">
                <a href="#event-mediastream-removestream">removestream</a>
              </code> events are fired.</p>
          </dd>

          <dt>void addStream (MediaStream stream, optional MediaConstraints
          constraints)</dt>

          <dd>
            <p>Attempts to starting sending the given stream to the remote
            peer. </p>

            <p>When the other peer starts sending a stream in this manner, an
            <code title="event-MediaStream-addstream">
                <a href="#event-mediastream-addstream">addstream</a>
              </code> event is fired at the <code>
                <a>PeerConnection</a>
              </code> object.</p>

            <p>When the <dfn id="dom-peerconnection-addstream">
                <code title="">addStream()</code>
              </dfn> method is invoked, the user agent MUST run the following
            steps:</p>

            <ol>
              <li>
                <p>If the <code>
                    <a>PeerConnection</a>
                  </code> object's <a
                href="#peerconnection-readiness-state"><code>PeerConnection</code>
                readiness state</a> is <code>
                    <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                  </code> (3), throw an <code>INVALID_STATE_ERR</code>
                exception.</p>
              </li>

              <li>
                <p>If <var>stream</var> is already in the <code>
                    <a>PeerConnection</a>
                  </code> object's <code
                    title="dom-PeerConnection-localStreams">
                    <a
                    href="#widl-PeerConnection-localStreams">localStreams</a>
                  </code> object, then abort these steps.</p>
              </li>

              <li>
                <p>Add <var>stream</var> to the end of the <code>
                    <a>PeerConnection</a>
                  </code> object's <code
                    title="dom-PeerConnection-localStreams">
                    <a
                    href="#widl-PeerConnection-localStreams">localStreams</a>
                  </code> object.</p>
              </li>

              <li>
                <p>Return from the method.</p>
              </li>

              <li>
                <p>Parse the <var>constraints</var> provided by the
                application and apply them to the MediaStream, if possible.
                NOTE - need to deal with throwing an exception here. </p>
              </li>

              <li>
                <p>Have the <code>
                    <a>PeerConnection</a>
                  </code> add a media stream for <var>stream</var> the next
                time the user agent <span
                title="provide a stable state">provides a stable state</span>.
                Any other pending stream additions and removals MUST be
                processed at the same time.</p>
              </li>
            </ol>
          </dd>

          <dt>void removeStream (MediaStream stream)</dt>

          <dd>
            <p>Stops sending the given stream to the remote peer.</p>

            <p>When the other peer stops sending a stream in this manner, a
            <code title="event-MediaStream-removestream">
                <a href="#event-mediastream-removestream">removestream</a>
              </code> event is fired at the <code>
                <a>PeerConnection</a>
              </code> object.</p>

            <p>When the <dfn id="dom-peerconnection-removestream">
                <code title="">removeStream()</code>
              </dfn> method is invoked, the user agent MUST run the following
            steps:</p>

            <ol>
              <li>
                <p>If the <code>
                    <a>PeerConnection</a>
                  </code> object's <a
                href="#peerconnection-readiness-state"><code>PeerConnection</code>
                readiness state</a> is <code>
                    <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                  </code> (3), throw an <code>INVALID_STATE_ERR</code>
                exception.</p>
              </li>

              <li>
                <p>If <var>stream</var> is not in the <code>
                    <a>PeerConnection</a>
                  </code> object's <code
                    title="dom-PeerConnection-localStreams">
                    <a
                    href="#widl-PeerConnection-localStreams">localStreams</a>
                  </code> object, then abort these steps.</p>
              </li>

              <li>
                <p>Remove <var>stream</var> from the <code>
                    <a>PeerConnection</a>
                  </code> object's <code
                    title="dom-PeerConnection-localStreams">
                    <a
                    href="#widl-PeerConnection-localStreams">localStreams</a>
                  </code> object.</p>
              </li>

              <li>
                <p>Return from the method.</p>
              </li>

              <li>
                <p>Have the <code>
                    <a>PeerConnection</a>
                  </code>remove the media stream for <var>stream</var> the
                next time the user agent <span
                title="provide a stable state">provides a stable state</span>.
                Any other pending stream additions and removals MUST be
                processed at the same time.</p>
              </li>

              <!-- section 9.1.1.2 -->
            </ol>
          </dd>

          <dt>void close ()</dt>

          <dd>
            <p>When the <dfn id="dom-peerconnection-close">
                <code title="">close()</code>
              </dfn> method is invoked, the user agent MUST run the following
            steps:</p>

            <ol>
              <li>
                <p>If the <code>
                    <a>PeerConnection</a>
                  </code> object's <a
                href="#peerconnection-readiness-state"><code>PeerConnection</code>
                readiness state</a> is <code>
                    <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                  </code> (3), throw an <code>INVALID_STATE_ERR</code>
                exception.</p>
              </li>

              <li>
                <p>Destroy the <a
                href="#peerconnection-ice-agent"><code>PeerConnection</code>
                ICE Agent</a>, abruptly ending any active ICE processing and
                any active streaming, and releasing any relevant resources
                (e.g. TURN permissions).</p>
              </li>

              <li>
                <p>Set the object's <a
                href="#peerconnection-readiness-state"><code>PeerConnection</code>
                readiness state</a> to <code>
                    <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                  </code> (3).</p>
              </li>
            </ol>

            <p class="note">The <code>
                <a href="#widl-PeerConnection-localStreams">localStreams</a>
              </code> and <code title="dom-PeerConnection-remoteStreams">
                <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
              </code> objects remain in the state they were in when the object
            was closed.</p>
          </dd>

          <dt>attribute Function? onconnecting</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-connecting">connecting</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface.</dd>

          <dt>attribute Function? onopen</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-open">open</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface.</dd>

          <dt>attribute Function? onstatechange</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-open">open</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface. It is called any time the readyState changes.
          </dd>

          <dt>attribute Function? onaddstream</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-addstream">addstream</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface.</dd>

          <dt>attribute Function? onremovestream</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-removestream">removestream</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface.</dd>

          <dt>attribute Function? onicechange</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-icechange">icechange</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface. It is called any time the iceState
          changes.</dd>
        </dl>

        <div class="idl" title="PeerConnection implements EventTarget" />
      </section>

      <section>
        <h3>SignalingCallback</h3>

        <dl class="idl"
            title="[Callback, NoInterfaceObject] interface SignalingCallback">
          <dt>void handleEvent (DOMString message, PeerConnection source)</dt>

          <dd>Def TBD</dd>
        </dl>
      </section>

      <section>
        <h3>Examples</h3>

        <div>
          <p>When two peers decide they are going to set up a connection to
          each other, they both go through these steps. The STUN/TURN server
          configuration describes a server they can use to get things like
          their public IP address or to set up NAT traversal. They also have
          to send data for the signaling channel to each other using the same
          out-of-band mechanism they used to establish that they were going to
          communicate in the first place.</p>

          <pre class="example sh_javascript"> TODO</pre>
        </div>
      </section>
    </section>

    <section>
      <h2>The data stream</h2>

      <p class="note">Although progress is being made, there is currently not
      enough agreement on the data channel to write it up. This section will
      be filled in as rough consensus is reached.</p>
    </section>

    <section>
      <h2>Garbage collection</h2>

      <p>A <code>Window</code> object <dfn
      id="concept-peerconnection-owner">has a strong reference</dfn> to any
      <code>
          <a>PeerConnection</a>
        </code> objects created from the constructor whose global object is
      that <code>Window</code> object.</p>

      <!-- we could be less strict here, e.g. dropping the reference when
  there’s no way for an event to be fired because there’s no event handlers
  registered and there’s no way for the remote peer to notice anything because
  no media is streaming; or e.g. dropping the reference when the object reaches
  the CLOSED state. But as dropping the reference in those cases is black-box
  indistinguishable from keeping the reference, I haven't bothered to work out
  the exact rules. If you do change this, see the /unloading document cleanup
  steps/. -->
    </section>

    <section>
      <h2>Event definitions</h2>

      <section>
        <h3>MediaStreamTrackEvent</h3>

        <p>The <code>
            <a href="#event-mediastreamtracklist-addtrack">addtrack</a>
          </code> and <code title="event-MediaStreamTracklist-removetrack">
            <a href="#event-mediastreamtracklist-removetrack">removetrack</a>
          </code> events use the <code>
            <a>MediaStreamTrackEvent</a>
          </code> interface.</p>

        <p><dfn title="Fire a track event">Firing a track event named
        <var>e</var></dfn> with a <code>
            <a>MediaStreamTrack</a>
          </code> <var>track</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>
            <a>MediaStreamTrackEvent</a>
          </code> interface with the <code>
            <a href="#dom-mediastreamtrackevent-track">track</a>
          </code> attribute set to <var>track</var>, MUST be created and
        dispatched at the given target.</p>

        <dl class="idl" data-merge="MediaStreamTrackEventInit"
            title="[Constructor(DOMString type, optional MediaStreamTrackEventInit eventInitDict)]     interface MediaStreamTrackEvent : Event">
          <dt>readonly attribute MediaStreamTrack? track</dt>

          <dd>
            <p>The <dfn id="dom-mediastreamtrackevent-track">
                <code>track</code>
              </dfn> attribute represents the <code>
                <a>MediaStreamTrack</a>
              </code> object associated with the event.</p>
          </dd>
        </dl>

        <dl class="idl"
            title="dictionary MediaStreamTrackEventInit : EventInit">
          <dt>MediaStreamTrack? track</dt>

          <dd>
            <p>-</p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>MediaStreamEvent</h3>

        <p>The <code>
            <a href="#event-mediastream-addstream">addstream</a>
          </code> and <code title="event-MediaStream-removestream">
            <a href="#event-mediastream-removestream">removestream</a>
          </code> events use the <code>
            <a>MediaStreamEvent</a>
          </code> interface.</p>

        <p><dfn id="fire-a-stream-event" title="fire a stream event">Firing a
        stream event named <var>e</var></dfn> with a <code>
            <a>MediaStream</a>
          </code> <var>stream</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>
            <a>MediaStreamEvent</a>
          </code> interface with the <code>
            <a href="#dom-mediastreamevent-stream">stream</a>
          </code> attribute set to <var title="">stream</var>, MUST be created
        and dispatched at the given target.</p>

        <dl class="idl" data-merge="MediaStreamEventInit"
            title="[Constructor(DOMString type, optional MediaStreamEventInit eventInitDict)] interface MediaStreamEvent : Event">
          <dt>readonly attribute MediaStream? stream</dt>

          <dd>
            <p>The <dfn id="dom-mediastreamevent-stream">
                <code>stream</code>
              </dfn> attribute represents the <code>
                <a>MediaStream</a>
              </code> object associated with the event.</p>
          </dd>
        </dl>

        <dl class="idl" title="dictionary MediaStreamEventInit : EventInit">
          <dt>MediaStream? stream</dt>

          <dd>
            <p>-</p>
          </dd>
        </dl>
      </section>
    </section>

    <section class="informative">
      <h2>Event summary</h2>

      <p>The following event fires on <code>
          <a>MediaStream</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastream-ended">
                <code>ended</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStream</a>
              </code> <a>finished</a> as a result of all tracks in the <code>
                <a>MediaStream</a>
              </code> <a title="ended">ending</a>.</td>
          </tr>
        </tbody>
      </table>

      <p>The following event fires on <code>
          <a>MediaStreamTrack</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastreamtrack-muted">
                <code>muted</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source is temporarily unable to provide
            data.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtrack-unmuted">
                <code>unmuted</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source is live again after having been
            temporarily unable to provide data.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtrack-ended">
                <code>ended</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source will no longer provide any data, either
            because the user revoked the permissions, or because the source
            device has been ejected, or because the remote peer stopped
            sending data, or because the <code>
                <a href="#dom-mediastream-stop">stop()</a>
              </code> method was invoked.</td>
          </tr>
        </tbody>
      </table>

      <p>The following event fires on <code>
          <a>MediaStreamTrackList</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastreamtracklist-addtrack">
                <code>addtrack</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamTrackEvent</a>
              </code>
            </td>

            <td>A new <code>
                <a>MediaStreamTrack</a>
              </code> has been added to this list.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtracklist-removetrack">
                <code>removetrack</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamTrackEvent</a>
              </code>
            </td>

            <td>A <code>
                <a>MediaStreamTrack</a>
              </code> has been removed from this list.</td>
          </tr>
        </tbody>
      </table>

      <p>The following events fire on <code>
          <a>PeerConnection</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastream-connecting">
                <code>connecting</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The ICE Agent has begun negotiating with the peer. This can
            happen multiple times during the lifetime of the <code>
                <a>PeerConnection</a>
              </code> object.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastream-open">
                <code>open</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The ICE Agent has finished negotiating with the peer.</td>
          </tr>

          <!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-PeerConnection-close">close()</code> method was
            called. </td>
          </tr>
          -->

          <tr>
            <td>
              <dfn id="event-mediastream-message">
                <code>message</code>
              </dfn>
            </td>

            <td>
              <code>MessageEvent</code>
            </td>

            <td>A <!--<a href="#data-udp-media-stream">-->data UDP media
            stream<!--</a>--> message was received.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastream-addstream">
                <code>addstream</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamEvent</a>
              </code>
            </td>

            <td>A new stream has been added to the <code
                title="dom-PeerConnection-remoteStreams">
                <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
              </code> array.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastream-removestream">
                <code>removestream</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamEvent</a>
              </code>
            </td>

            <td>A stream has been removed from the <code
                title="dom-PeerConnection-remoteStreams">
                <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
              </code> array.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2 id="sec-iana">IANA Registrations</h2>

      
      <section>
        <h2
        id="application_html-peer-connection-data">application/html-peer-connection-data</h2>

        <p>This registration is for community review and will be submitted to
        the IESG for review, approval, and registration with IANA.</p>

        <!--
   To: ietf-types@iana.org
   Subject: Registration of media type application/html-peer-connection-data
  -->

        <dl>
          <dt>Type name:</dt>

          <dd>application</dd>

          <dt>Subtype name:</dt>

          <dd>html-peer-connection-data</dd>

          <dt>Required parameters:</dt>

          <dd>No REQUIRED parameters</dd>

          <dt>Optional parameters:</dt>

          <dd>No OPTIONAL parameters</dd>

          <dt>Encoding considerations:</dt>

          <dd>This MIME type defines a binary protocol format which uses UTF-8
          for text encoding.</dd>

          <dt>Security considerations:</dt>

          <dd>
            <p>This format is used for encoding UDP packets transmitted by
            potentially hostile Web page content via a trusted user agent to a
            destination selected by a potentially hostile remote server. To
            prevent this mechanism from being abused for cross-protocol
            attacks, all the data in these packets is masked so as to appear
            to be random noise. The intent of this masking is to reduce the
            potential attack scenarios to those already possible
            previously.</p>

            <p>However, this feature still allows random data to be sent to
            destinations that might not normally have been able to receive
            them, such as to hosts within the victim's intranet. If a service
            within such an intranet cannot handle receiving UDP packets
            containing random noise, it might be vulnerable to attack from
            this feature.</p>
          </dd>

          <dt>Interoperability considerations:</dt>

          <dd>Rules for processing both conforming and non-conforming content
          are defined in this specification.</dd>

          <dt>Published specification:</dt>

          <dd>This document is the relevant specification.</dd>

          <dt>Applications that use this media type:</dt>

          <dd>This type is only intended for use with SDP. [[!SDP]]</dd>

          <dt>Additional information:</dt>

          <dd>
            <dl>
              <dt>Magic number(s):</dt>

              <dd>No sequence of bytes can uniquely identify data in this
              format, as all data in this format is intentionally masked to
              avoid cross-protocol attacks.</dd>

              <dt>File extension(s):</dt>

              <dd>This format is not for use with files.</dd>

              <dt>Macintosh file type code(s):</dt>

              <dd>This format is not for use with files.</dd>
            </dl>
          </dd>

          <dt>Person &amp; email address to contact for further
          information:</dt>

          <dd>Daniel C. Burnett &lt;dburnett@voxeo.com&gt;</dd>

          <dt>Intended usage:</dt>

          <dd>Common</dd>

          <dt>Restrictions on usage:</dt>

          <dd>No restrictions apply.</dd>

          <dt>Author:</dt>

          <dd>Daniel C. Burnett &lt;dburnett@voxeo.com&gt;</dd>

          <dt>Change controller:</dt>

          <dd>W3C</dd>
        </dl>

        <p>Fragment identifiers cannot be used with <code>
            <a
            href="#application_html-peer-connection-data">application/html-peer-connection-data</a>
          </code> as URLs cannot be used to identify streams that use this
        format.</p>
      </section>
    </section>

    <section>
      <h2>Change Log</h2>

      <p> This section will be removed before publication. </p>

      <h3> To Do Items </h3>

      <p> Need a way to indicate the type of the SDP when passing SDP strings.
      </p>

      <h3> Changes since 12 January 2012</h3>

      <ol>
        <li> Clarified what relation of Stream, Track, and Channel. </li>
      </ol>

      <h3> Changes since 17 October 2011</h3>

      <ol>
        <li>Tweak the introduction text and add a reference to the IETF RTCWEB
        group.</li>

        <li>Changed the first argument to getUserMedia to be an object.</li>

        <li>Added a MediaStreamHints object as a second argument to
        PeerConnection.addStream.</li>

        <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
      </ol>

      <h3> Changes since 23 August 2011</h3>

      <ol>
        <li> Separated the SDP and ICE Agent into separate agents and added
        explicit state attributes for each. </li>

        <li> Removed the send method from PeerConenction and associated
        callback function. </li>

        <li>Modified MediaStream() constructor to take a list of
        MediaStreamTrack objects instead of a MediaStream. Removed text about
        MediaStream parent and child relationship.</li>

        <li>Added abstract.</li>

        <li>Moved a few paragraphs from the MediaStreamTrack.label section to
        the MediaStream.label section (where they belong).</li>

        <li>Split MediaStream.tracks into MediaStream.audioTracks and
        MediaStream.videoTracks.</li>

        <li>Removed a sentence that implied that track access is limited to
        LocalMediaStream.</li>

        <li>Updated a few getUserMedia()-examples to use
        MediaStreamOptions.</li>

        <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in
        example code.</li>

        <li>Fixed some broken getUserMedia() links.</li>

        <li>Introduced state handling on MediaStreamTrack (removed state
        handling from MediaStream).</li>

        <li>Reintroduced onended on MediaStream to simplify checking if all
        tracks are ended.</li>

        <li>Aligned the MediaStreamTrack ended event dispatching behavior with
        that of MediaStream.</li>

        <li>Updated the LocalMediaStream.stop() algorithm to implicitly use
        the end track algorithm.</li>

        <li>Replaced an occurrence the term finished track with ended track
        (to align with rest of spec).</li>

        <li>Moved (and extended) the explanation about track references and
        media sources from LocalMediaStream to MediaStreamTrack.</li>

        <li>Removed section "Obtaining local multimedia content".</li>

        <li>Updated getUserMedia() calls in examples (changes in Media Capture
        TF spec).</li>

        <li>Introduced MediaStreamTrackList interface with support for adding
        and removing tracks.</li>

        <li>Updated the algorithm that is run when PeerConnection receives a
        stream (create new stream when negotiated instead of when data
        arrives).</li>
      </ol>
    </section>

    <section class="appendix">
      <h2>Acknowledgements</h2>

      <p>The editors wish to thank the Working Group chairs, Harald Alvestrand
      and Stefan Håkansson, for their support.</p>
    </section>
  </body>
</html>
